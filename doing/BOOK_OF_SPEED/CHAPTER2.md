# 网页 2.0 

在最开始的时候，互联网还是一个页面检索系统，起初只是被设计用来提供相互链接的页面。当你在浏览器地址栏输入一个地址或者点击页面上的一个链接，一个新的页面就会从服务器上返回并展示在浏览器窗口上。但在 Web 2.0 和 Web 2.0 前期开始，互联网的世界就有了大量的变化。在 Javascript、CSS 和 AJAX(XMLHttpRequest) 的帮助下，网页比起静态页面拥有了更多程序和应用的特性。

本章会把现代的网页（或互联网应用，也就是 Page 2.0、网页 2.0）类比成人类的一生。在介绍完网页 2.0 的每个成长阶段后，本章会大概列举在每个阶段哪些地方可以进行优化。后面的章节则会逐个深入这些优化方法，并且告诉你怎么搭建一个为速度优化的互联网应用。


## 网页 2.0 的一生

让我们一起看下在 **图2.1.** 的时间线，它描述了网页 2.0 一生中的各个阶段，并且每个阶段对应了人类成长的关键历程。

![网页 2.0 的一生](http://img04.taobaocdn.com/tps/i4/T1ZmBoXxlbXXX5Ovs7-800-600.png "网页 2.0 的一生")

*图 2.1. 网页 2.0 的一生*

### 从请求开始

一切都从一个请求开始。人们在浏览器地址栏输入一个 URL 或者点击一个链接，从此刻开始一个网页就准备在服务器中「受孕」。我们会在第三章详细的介绍什么是请求以及请求的过程。

### 生成 HTML 文档

下一步就是服务器「怀孕」整个页面的过程。在互联网初期，这个阶段只是简单地通过服务软件从硬盘中检索请求的静态文档（HTML 文件），并读取其内容。但现在情况则复杂很多，因为大多数网站都使用了服务端编程语言如 PHP、Ruby、Python、Perl 等等去生成动态的 HTML 文档。

服务端编程语言（一般称作服务端脚本）一开始会从某个地方获取部分数据，通常是数据库或者别的互联网服务。然后服务器把数据碎片集中并用一些字符串整合在一起，组成 HTML 代码，这就是一个动态生成的页面。

本书将不准备讨论这部分的优化，因为这个地方不值得去花费太多的时间。

### 开始响应并返回

幸运的是，如果没有什么纷纷扰扰，比如「流产」或 404 什么的，「怀孕」的过程很快就会完成，然后生成的 HTML 文档就会通过 HTTP 响应返回给浏览器。

一个 2.0 版的网页就正式诞生了。

### 瀑布流

接下来会进入瀑布流阶段，浏览器会下载页面剩下所需要的资源，如图片、脚本、样式等等。这个阶段会在浏览器触发 onload 事件时结束，此时这个 HTML 文档所引用的所有资源都已经被下载下来。这个阶段大概对应人类的少年时期，最后终于毕业并成为了「页面妹子」[译者注：原名 Ms. Page]。对于页面优化来说，这个阶段是最重要的。本书从第三章开始，将专注于介绍这一阶段的优化手段。

### 完整的页面

onload 事件触发完之后，「页面妹子」开始「安定」阶段下来并继续寻找真正的自己。用专业一点的说法就是，在这一阶段脚本（Javascripts）开始执行一些初始化工作，比如在 DOM 元素上绑定事件、添加渐进增强效果、加载跟多的资源或组件、或者异步请求一些额外的数据。

然后页面基本就加载完成了，浏览器上的状态栏停止显示正在下载的资源 URL，标签上的菊花停止转动，鼠标图案不再是忙碌中，用户终于可以<s>挑逗妹子</s>跟页面进行交互了。这一阶段也可以看成我们的「页面妹子」从敏感词和西欧背包旅行回来，找了一份稳定的工作，买了一个烧烤炉，准备结婚。[译者注：我也不知道为什么要在结婚前烧烤炉]

### 用户开始交互行为

生活继续进行，这一阶段用户会跟页面产生交互行为。有些网页的大部分是安静且平凡的，比如一个新闻或者一篇博客，这些页面让人感到兴奋的地方可能就是旁边那个广告切换了那么一下。不过，其它网页（想象下网页邮箱）则是一直在<s>上下上下进进出出</s>上传和下载，不断在获取新数据，更新页面，永不停息。

### 终结，和下一个请求的来临

结局总会来临，当下一个请求产生前一切都会结束。用户的点击一旦离开了页面，发起了新的请求，我们的「页面婆婆」会在浏览器的 onunload 事件触发后安息。


## 页面什么时候才是「加载完成」？

onload 是一个明确而具体的事件用以表示页面已经准备好了，但事情不总是那么简单。就好像在现实生活中很难去描述一个人是否已经「成熟」。「用户认为的加载完成」的时间是不确定的，它可能发生在 onload 事件之前或者之后（**图 2.2**）。它跟页面内容和用户的不同有很大关系。

![用户认为的加载完成](http://img01.taobaocdn.com/tps/i1/T16I8nXsdgXXXo3mrI-400-293.png "用户认为的加载完成")

*图 2.2. 「用户认为的加载完成」的时间根据页面内容不同和用户不同而产生变化*

如果是页面只是一篇文章，那么它在标题和内容出现时就可以被认为是已经加载完成，用户可以阅读并且跟页面交互，虽然图片和广告可能还在下载中。但有些时候，onload 事件可能相对来说很快就触发了，但页面真正的内容还在接收中，屏幕还一片空白（或者显示着「加载中」并附带一个转不停的菊花），用户除了等待什么也做不了。

这对不同用户来说定义也不同，有些用户会等页面完全停止加载和变化时才进行操作，而别的人可能会在页面刚出来一点内容时就滚动鼠标了 -- 因为大多数页面顶部是广告或者导航，造成了用户条件反射式的反应。

其实对你的网页来说，「用户认为的加载完成」所指的时间完全由你的页面内容和用户类型决定。但鉴于很难精确定义这个时间，通常 **onload** 或者 **DOMContentLoaded** 事件的发生时间在性能测量用途上也能代表大致的时间值。


## 咱们继续

现在我们确认了一个页面中最重要的几个阶段，紧接着我们继续深入分析，看看我们能在各个阶段做哪些优化。

大部分情况，最最重要的部分是瀑布流阶段的优化，因为页面加载的大部分时间会花在这一阶段，但其实在其它阶段也有优化手段。对一个页面来说，找出它的性能瓶颈所在十分重要，然后优先解决这一部分带来的效果更直接和有效。

下面是对每个阶段能做的优化手段的一些总结。不要担心看不懂，本书后面的章节会逐一介绍它们。

* 请求阶段的优化，如减少请求的大小（附带更少甚至不需要 cookie，如图片等静态资源）。
* 瀑布流阶段的优化，可以分为以下几个点：
  * 减少页面资源：很明显，如果请求的资源越少，瀑布流长度则会越短。在第三章中，我们会介绍这些方法 - 减少 HTTP 请求，合并资源文件，使用 CSS 精灵（CSS Sprites），使用 data URI 或 MHTML，缓存或设置「永不过期」的规则以改善重复访问的体验，去除重复，合并类似资源，清除无效链接。
  * 减小文件大小：在做完去除了无用资源和合并文件后，剩下的就应该减少资源文件的大小了，而且理所当然地越小越好。一般的手段是压缩、精简、清空会返回状态 204 的请求。（这些技术会在第四章详细介绍）
  * 把道路理顺：有些资源的请求比起其它资源会损耗更多的时间和性能，而且不是所有资源都是同时请求的。同时请求是很好的机制因为意味着相同的时间内下载的内容更多，瀑布流也会更早的结束。第六章会介绍无阻塞 Javascript 和 CSS，同时包括减少 DNS 查询重定向的方法。
  * 提前开始请求：如果瀑布流越早开始，理所当然会越早结束。第九章将会介绍提前推送页面代码的技术和 HTTP 分段传送编码。(就像如果你先知道 Ta 会是一个女娃，就可以提前准备一些粉色的玩具了)
  
* onload 事件前的后半段优化，事实上你可以在这部分进行优化。比如可以将部分脚本初始化过程放在 **DOMContentLoaded** 事件触发时执行，而不必总是等到 **onload** 事件触发。
* 交互阶段的优化（成年阶段）则包括榨干 CSS 和 Javascript 的性能，使用户的交互和 UI 更加流畅、痛快、及时响应。（第七和八章会介绍）
* 一直到最后也可以进行优化。老页面可以为它的子页面或孙页面提前加载一些共用的资源，用作预加速。


## 动手吧！
本章介绍了现代 2.0 网页一生中的几个主要阶段，并且为各个阶段提出对应的加速方法。

紧接着，我们将深入探索各个优化手段。

