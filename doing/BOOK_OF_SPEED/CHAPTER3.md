# 减少页面资源

减少页面请求资源的数量是性能优化中的「黄金原则」，是搭建最快页面过程中最重要的优化手段。如果你只有时间对其中一个部分进行优化，则请毫不犹豫地选择这一部分。

就像常识一样，更少的页面资源 - 如更少的图片、脚本和样式，会使页面变得更轻量，因此加载会更快。但减少页面资源并不意味着减少页面的特色或功能。本章（或本书）一开始就假设需要优化的页面在进行优化之后会保留原有的设计和所有的功能。

为了有效地让各位更深入地了解性能优化中的艺术和科学，本章还会介绍类似 HTTP 和 TCP/IP 协议等的技术细节。如果这些部分让你感到措手不及，请别慌，你可以慢慢理解和吸收。

## 瀑布流

为了优化页面的加载时间，首先必须了解整个页面是怎么运作的 - 浏览器是怎么加载页面的？哪些过程可能拖慢了加载进度？如果不先了解这些问题，漫无目的的优化只会浪费时间；反正针对这些部分的优化则会更有效果。

一般来说，了解页面加载的过程 - 指的是从输入 URL 开始到浏览器加载完整个页面的过程，也是非常有用的。

为了更清晰地描述当页面加载时浏览器后台会发生什么事情，很多浏览器都提供了一个叫「瀑布流」的可视化工具。距两个例子：

* 在 Firefox 中，可以从 Firebug 的「网络」（Net）标签调出瀑布流工具（**图 3.1.**）
* 低版本的 Internet Explorer 可以用在线工具 WebPageTest.org 查看瀑布流（**图 3.2.**），这样免安装任何插件。[译者注：IE9 开始可以查看网络瀑布流]

![Firebug 网络标签下的瀑布流工具](http://img02.taobaocdn.com/tps/i2/T16MVrXAdfXXaRud.7-800-421.jpg "Firebug 网络标签下的瀑布流工具")

*图 3.1. Firebug 网络标签下的瀑布流工具*

![WebPage Test 对 twitter.com 产生的瀑布流](http://img02.taobaocdn.com/tps/i2/T1bo0qXBdhXXX_JF_4-727-618.png "WebPage Test 对 twitter.com 产生的瀑布流")

*图 3.2. 在 WebPage Test 访问 twitter.com 产生的瀑布流*

**图 3.2. **显示了在 WebPageTest 上用 IE7 打开 twitter.com 所生成的瀑布流。可以看到，HTML 文档是最先开始下载的，然后紧接着下载其它被页面引用的资源，也包括子资源所引用的资源（如 CSS 文件中引用的背景文件）。从图中可以看出，所有资源并不是同时下载的。事实上上面这张图只是一部分的截图，瀑布流会一直增长知道页面所有资源都下载完成。这样一张由各个资源下载进程组成的图的确很像一个「瀑布」。

从图中可以看出，twitter.com 的 HTML 文档只用了不到一秒的时间就下载完成，但其它资源一起却花费了超过四秒的时间。在这个例子中，就像大多数网站那样，也适用经典的 80/20 法则：页面自身文档的下载只占用了 20% 的时间，其余时间都消耗在下载其它资源上面。所以我们更应该把时间花在优化正确的部分上，因为优化 80% 的一半和优化 20% 的一半带来的结果明显是不一样的。

## HTTP 请求

在瀑布流中每个资源的请求都对应着一条彩色的条形。每个条形代表着一个请求，而里面不一样的颜色则代表着一个特定的过程。条形的总长或里面各个颜色所占长度则代表着它们所消耗的时间。接着我们深入分析一下各个颜色代表的过程，以 Twitter 的 HTML 文档为例（**图 3.3.**）

![一个 HTTP 请求](http://img02.taobaocdn.com/tps/i2/T1q_tqXz4hXXXjwZzV-395-19.png "一个 HTTP 请求")

*图 3.3. 一个 HTTP 请求*

* 深绿色代表查询 DNS 所消耗的时间。DNS（Domain Name Service 域名查询服务）查询的过程是指把 twitter.com 对应成 IP 地址（如 128.242.240.20）的过程，这是浏览器访问服务器必需的一个过程。就像查号码本一样，浏览器只知道名字（域名），但它需要的是号码（IP 地址）。
  
  在**图 3.2. **中可以看到每个域名都有一个 DNS 查询的过程（twitter.com, a1.twimg.com, a3.twimg.com, s.twimg.com），这是因为每个子域名都可能各自在不同的服务器上，拥有不同的 IP 地址。
  
* 橙色代表浏览器与服务器建立链接所需要的时间。我们接下来只会谈其中一部分。

* 亮绿色代表着 TTFB（time-to-first byte，第一字节达到时间），是指浏览器等待服务器返回的第一个字节所需要的时间。很大多数情况下服务器需要时间去组合和完成页面的代码。如果去优化服务端脚本和数据库的话，所优化的时间就会在这一阶段体现。可以明显看出，相对于其它部分来说，这一部分不值得专注，因为它带来的影响是微乎其微的（当然除非服务端出了什么严重差错）[译者注：作者认为这一部分的优化没有其它部分重要，但在我看来也十分重要，因为明显这一部分占用的时间是最多的]

* 蓝色就代笔着实际下载所需要的时间

纵观整个图表，会发现蓝色部分并不多。这意味着大多数时间并不花在实际下载上面。

## 有关网速的误区

你可以听到过这样的话：『现在每个人都用宽带啦巴拉巴拉』或者『我们的目标用户都是专业网民，他们都有很快的网络。』这些都是懒得去优化网站的借口，实质就是对用户的不负责任。这里有几个关于「网速理论」的误区。

首先，无论是美国还是美国以外，仍有大量用户使用低速网络[译者注：作者是美国人]。部分用户仍在使用调制解调器连接网络，而且更多用户在使用智能手机上网，他们的网络或者慢或者不稳定。其他人则可能是在咖啡店或家里跟别人共享 WiFi 网络。实际上要拖慢共享 WiFi 链接速度的方法很简单，只要有个人再视频聊天或者你家微波炉开了，下载速度就会受到很大影响。

此外，一个不多人知道的事实是，一般 ISP（Internet Service Provider 网络服务提供商[译者注：如电信、联通]）所提供的上载速度只有总带宽的 20% 左右，这不仅仅影响着大文件的上传，普通的请求也受到此限制。

最后，如你所见，瀑布流中大部分的时间被花在其它阶段上而不是实际的下载过程，然而网速的快慢只能对蓝色的下载过程有点帮助。

### 「线路管道」

你可以听说过一个恶搞的词叫 intertubes（互联管道），用以描述互联网的构造布局。这虽然是不正确的，但这个概念仍可以类比成「带宽」。如果把调制解调器线路类比成一条普通的胶管，那宽带线路则是一条有更大直径的「粗」胶管，即「宽」带。

在这些「胶管」里面流动的是数据包。每个文件会被分成一堆数据包进行发送。数据包以 2/3 光速传输 - 已经非常快了，而且能改进的空间很小。「粗胶管」意味着同一时间内允许更多和更大的数据包进行传送，反之「细胶管」能同时传送的数据包更小也更少，导致数据包按顺序排列陆续发送，传输速度变慢。

但实际上「胖胶管」的优势并不大，你可以接受这个事实然后继续阅读下一节，抑或继续让自己停留在了解皮毛的阶段。

### 文件传输

在文件传输初始化之前，浏览器和服务器之间要建立一条链接。建立链接所花费的时间在瀑布流图表中用了橙色来表示。

> ## TCP/IP
> IP 协议通过网络把信息（数据包）从一台电脑传送至另外一台电脑。TCP 协议模糊了数据包在终端间解包和组装的细节。TCP 协议用一些头信息描述每个数据包里面的内容。SYN 和 ACK 就是类似的头信息。SYN（序列号）用来分辨不同数据包让相同的信息能组合在一起，因为现实中的网络其实是非常混乱的，有些数据包的达到顺序可能错乱。ACK 意思是 「Acknowledged」（已收到），表示接受方已经接收到信息，并做出答应的回复。

一个新的链接（**图 3.4.**）通过三次握手建立：

![三次握手](http://img03.taobaocdn.com/tps/i3/T1WIJuXqldXXat2v_O-721-225.png "三次握手")

*图 3.4. 三次握手*

* 浏览器发送一个带有序列号的 SYN 数据包
* 服务器接收后返回 ACK 数据包，并再发送一个 SYN 数据包
* 浏览器响应 ACK 数据包，现在两方都已相互认识，可以相互「聊天」了（传输数据）

这些握手数据包非常小，它们以相同的速度传输，受线路带宽的影响并不大。用户即使有很快的网速，但在这一阶段网速并不会带来优势。

一旦链接建立，文件（比如一张图片）的实际传输过程就会开始。文件一般会根据其大小被分割成一系列的数据包。服务器每发送一个数据包就会等 ACK 响应返回。ACK 响应也可以额外地附带一些如「嗨，其实我可以接收更大块的数据包」，然后服务器就响应之并发送更大的数据包。这个过程会重复几次，直到整个线路「饱和」，数据包的大小达到最合适的状态。这是现实中我们看到的下载速度一开始都很慢的原因，这也说明了宽带并没有我们想象中那么重要。高速网络会对下载大文件有很大帮助，但对于不同域名下的一堆小文件（每个都需要 DNS 查询、建立链接、链接一开始是很慢的），网速并没有太大的效用。

对于整个网络传输环境，你可以把它看作是一个错综复杂的森林。浏览器和客户端之间其实并没有真正「面对面」的交流，它们之间参杂着各种的 ISP 和代理服务器等等。很多意想不到的事情会在这个森林中发生，导致传输速度损失。有时候是数据包丢失，或者数据包在传输过程中被哪个阿瘪给扔了。这种情况服务器不会收到 ACK 响应，在超过一定时间后，服务器就会发送这个数据包。再或者有些时候客户端被太多的数据包给「堵住」了（想象一下移动设备没内存了），没法再处理和响应 ACK 数据。这也是现存 TCP 通信开始的时候都很慢的原因 - 服务器总是不能预先知道对方是哪个客户端，每次都需要三次握手才能继续通信。

NetMon 是一个 Window 下的工具，可以从数据包层面监听和查看系统里的网络活动。另一个来自微软的工具 VRTA（Visual RoundTrip Analyer 可视化路由分析），基于 NetMon，可以更友好地用图表表现数据。**图 3.5.** 就是一个请求的例子，可以看出 TCP 请求开始的时候是最慢的。蓝色的条形慢慢增高表示在慢慢地打开 TCP 链路的带宽。紫色的条形则代表着建立链接，灰色是 TTFB。**图 3.6.** 是鼠标移到 VRTA 上显示的一些信息，你可能认得前面三行就是那三个握手数据包。

![VRTA 里面的一个请求](http://img03.taobaocdn.com/tps/i3/T1PVVtXxBeXXbtDnrr-360-116.png "VRTA 里面的一个请求")

*图 3.5. VRTA 里面的一个请求，可以更直观地看出 TCP 请求开始时很慢*

![VRTA 里的数据包列表](http://img02.taobaocdn.com/tps/i2/T1QCltXvtdXXbDEozc-455-148.png "VRTA 里的数据包列表")

*图 3.6. VRTA 里的数据包列表*

最后，给网速神话致命一击的事实 - 大多数浏览器只支持对同一个域名同时建立两个链接。这意味着只有两个文件在同时下载，造成网速的浪费。不过因为这是 HTTP 标准决定的，所以我们倒不能责怪浏览器们。问题是这些标准是在很久之前就制定的。不过幸运的是，黑暗尽头总有光 - 新浏览器（Firefox 3+，Safari 4+，Chrome，Opera 10+，IE8+）提供了 6 到 8 个并发链接。但还占有大部分市场份额的低端浏览器如 IE6-7 仍然只有两个。

### 总结一下

我们总结一下为什么大量 HTTP 请求（即大量页面资源请求）是罪孽的，而且为什么网速并不是解决性能问题的最好方案：

* 每个 HTTP 请求都带有额外的信息
* 下载文件实际所需要的时间只占请求时间的一小部分
* 高速网络只对下载文件的时间有帮助，尤其是大文件
* 网速对其它过程并没有太大的影响，如 DNS 查询、建立链接、TTFB
* 「宽」带实际上并没有完全发挥它的优势
* 浏览器限制了每个域名下的并发连接数
* 大量的用户（如移动用户）并没有使用宽带或者高速网络


## 有关缓存的误区

你可能觉得整个 TCP 嘛嘛的是一件很神奇的东西（虽然有点枯燥），但你可能也会怀疑这些东西真的有用吗？页面的资源如图片和样式文件，在第一次访问过页面之后，所有的东西不是经常放在缓存中了吗？

然而事实就是，「都在缓存里」是另一个误解。实际上很多原因会导致大部分用户访问网站时是不带任何缓存的。

来自雅虎前台页面的一个实验数据表明：

* 40% - 60% 的日常用户访问时没有带任何缓存
* 20% 的页面访问都是不带任何缓存的访问

鉴于 yahoo.com 是一个非常出名的门户网站而且它是很多用户的默认首页，这已经能推翻「用户访问时总是带着缓存」这一观点了。结果真让人丧气，有约一半的用户今天访问过网站之后明天再访问时缓存就不见了。

那究竟为什么这么多空缓存？其中涉及的原因有很多：用户自行清空了缓存，浏览器在关闭时自动清除，或者杀毒软件清空了等等。再或者缓存满了，在第二次访问前它就被删除了。大多数浏览器有 50MB 的缓存空间，实际上这个容量并没有你想象中那么大，尤其是访问现在那些都是富媒体的页面，而且我们现在的上网习惯也会让这个容量十分不足（因为相对于几年前，我们在网上待更长时间，打开的页面更多）。

因此，时刻为未缓存页面优化是十分重要的。本章结尾会提到怎么改善缓存效果。


## 合并脚本和样式

到现在为止，你应该清除的知道页面发出越多的请求，就会有更多额外的消耗，导致页面越慢。减少页面的 HTTP 请求则是最好的加速方法。

让我们来看一下具体怎么减少资源请求。当然，也许最简单的方法是从页面中剔除某些功能，但我们需要的是保持同样的设计和页面功能而把页面加速。所以剩下的方法就是把已有的页面资源整合在一起，以减少独立请求。

一般来说，一个页面上会引用好几个 Javascript 脚本和 stylesheets 样式文件。这种情况对开发带来很大便利，但发布到线上时就要分别把所有 Javascript 文件和 CSS 文件合并成一个文件。

举个例子，一个页面使用了 jQuery 框架和两个 jQuery 插件，还包括一些专门给这个页面编写的非框架代码。然后这个页面的代码的一部分就像是这样的：

    <script src="js/jquery.js" type="text/javascript"></script>
    <script src="js/jquery.form.js" type="text/javascript"></script>
    <script src="js/jquery.lightbox.js" type="text/javascript"></script>
    <script src="js/myapplication.js" type="text/javascript"></script>

接着我们新建一个 all.js 把上面所有脚本文件的内容合并在一起，这样就需要一个 script 标签：

    <script src="js/all.js" type="text/javascript"></script>
    
这样我们就节省了三个 HTTP 请求，页面加载变得更快。第六章会详细介绍怎么优化 Javascript 脚本，其中提到它们的加载受浏览器行为影响，会按顺序逐个下载，导致拖慢整个瀑布流。因此，确保页面内有最少的脚本文件是非常必要的。

在合并脚本文件之后，我们重复一遍相同的操作来合并样式。这样只需要一个样式文件：
     
    <link href="all.css" type="text/css" rel="stylesheet" />
     
一个页面一般会分出几个媒体类型的样式（media stylesheets），但毫无例外这些不同媒体类型的样式都需要合并，放进 `@media print {…}` 声明里面。第八章我们会更详细地介绍优化 CSS 以提高渲染效率的方法，另外有个地方很让人好奇，就是一旦媒体类型是 **print** 的样式没加载之前，页面不会渲染任何东西。

[译者注：这一段有很多错误的地方。首先不同媒体类型的样式不应该直接合并在`@media print`，媒体类型选择器并不能嵌套，但可以把不同媒体类型放在同一个 CSS 文件。第二，浏览器只会阻塞影响此页面的样式文件，对于一般 PC 来说，浏览器会等待媒体类型为空或「all」或「screen」的样式加载完成才开始渲染，并不是「print」]

合并资源文件的另外一个好处是合并后的文件大小比合并前小文件大小的总和要更小，因为一般合并时会使用压缩，这一部分会在下一章介绍。


### 缺点和解决方法

很多优化手段都有它们各自的弊端，而大多数就是优化后可能会带来开发上的不便利。想象一下忙活了一整天，修复了很久 IE6 下的 bug，准备发布代码上线前，还要一个一个地手动把各种资源打包在一起，那是多痛苦的事。实际上合并和打包这些琐碎的操作可以用一些自动化代码完成，它甚至可以帮你直接把代码发布到线上。另一种选择就是用服务端脚本（一般叫自动打包脚本）去按需打包，自动打包脚本可以根据一定条件从一堆资源文件或代码中提取符合条件的进行打包。例如，YUI（Yahoo! User Interface）框架就使用了类似的服务端自动打包脚本，只合并所需要的文件。最后的 URL 是类似这样的：

    http://yui.yahooapis.com/combo?3.0.0/build/yui/yui-min.js&3.0.0/build/oop/oop-min.js&3.0.0/build/event-custom/event-custom-min.js
    
> ## HTTP 过期参数（Expires)
> 为打包后的文件设置合适的 HTTP 过期时间是很重要的，以保持更好的缓存效果。因为一般脚本文件并不会缓存。有关 Expires 的介绍会在后面提到，这里给出了用 PHP 设置合理的 Expires 参数的方法：
>>`$expiration = mktime() + 60 * 60 * 24 * 365 * 10; // 加上 10 年的时间
>> header('Expires: ' . gmdate('D, d M Y h:m:s', $expiration) . ' GMT');`


打包的另外一个缺点是代码会变得非常庞大，这可能会影响缓存因为只要改动里面一点点的话都需要重新打包，这样用户就必须重新下载整个打包后的文件。不过从另一个角度也说明了缓存并没有想象中重要，为没有缓存的情况去优化还是必须的。有一个解决方法是打包成两份文件，一份是框架性代码，一般很少改动；另一份是经常改动的代码。

尽管打包对开发带来不便，但这个方法还是强烈推荐的优化手段，它们带来的好处远比缺点重要。


## 合并图片

现在我们知道了合并脚本和样式为什么能改善性能，紧接着我们看一下怎么去减少那些大量的图片请求。当提到网页图片时，一般分为两种：

* 背景图片（Background images）类似于 CSS 里 `background-image` 和 `list-style-image` 所引用图片。这些「装饰性」的图片让页面看起来美轮美奂而且感觉很棒，但它们对于页面功能来说却不是必须的。一旦 CSS 被禁止，网页还是可以正常使用，虽然没那么好看。
* 内容图片（Content images）一般是 `<img />` 标签所引用的图片。叫它内容标签时因为它们专门为页面上某个目的而出现。即使浏览器禁用了 CSS，这些图片也是可见的。

接着让我们看下怎么减少这两种图片的请求 - 分别是合并成 CSS 精灵和使用 dataURI。这两种技术适用于任何类型的图片，但精灵图一般用于背景图，而 dataURI 则两者适用。

### CSS 精灵图

CSS 精灵图是把多张小图合并成一张大图以减少图片请求。制作过程很简单，只需要新建一张空白大图然后把小图逐个紧靠着粘贴在上面。然后用 CSS 属性 `background-position` 显示需要的那一部分。这是一项非常优秀的技术，因为可以轻易地把一堆小图标等合并成一张图片一个请求，在节省请求的同时了避免了请求带来的额外消耗。精灵图的另外一个好处是可以预加载图片。如果鼠标悬浮时显示一张新图，这一张新图完全可以是同一张图片，只不过是 `background-position` 改变了。

让我们看一下 Yahoo! 搜索页所用的一张精灵图。**图3.7.** 就是一张完整的精灵图，里面有大量的图标，而其他的一些图案我们一般称作「精灵元素」。在图片的下方可以看到一个小的地球图标，在 **图 3.8.** 中这个图标就使用在了「Show All」标签的旁边。

![Yahoo! 搜索页所使用的精灵图](http://img03.taobaocdn.com/tps/i3/T1y3hvXuNdXXaT1FD4-200-142.png "Yahoo! 搜索页所使用的精灵图")

*图 3.7. Yahoo! 搜索页所使用的精灵图*

![页面上所使用的地球图标](http://img03.taobaocdn.com/tps/i3/T1pc0vXCFdXXailrMN-196-206.png "页面上所使用的地球图标")

*图 3.8. 页面上所使用的地球图标*

一般使用 X 和 Y 坐标系统相对于顶部和左侧定位精灵图，那个地球图标的位置则是 x=101, y=108（**图 3.9.**）。为了在页面上显示这个图标，编写 CSS 代码时有以下步骤：

![地球图标在精灵图里的位置](http://img01.taobaocdn.com/tps/i1/T1zPhtXuphXXaT1FD4-200-142.png "地球图标在精灵图里的位置")

*图 3.9. 地球图标在精灵图里的位置* 

* 设置 `background-image` 为精灵图的 URL，如 `sprite.png`
* 设置 `background-position` 为精灵元素的坐标，带减号，上面的例子则是 `-101px -108px`
* 为了防止精灵图别的部分显示出来，一般会给页面元素设置跟精灵元素一样大小的宽高。

最后的 CSS 代码是这样的：

    .all-sites-icon {
      background-image: url(sprite.png);
      background-position: -101px -108px;
      width: 16px;
      height: 16px;
    }
    

### 制作精灵图的工具

制作和维护精灵图是一件苦差事，因为要一直计算各个小图的各种大小和位置。幸运的是有几个工具可以逃离这个苦海。其中一个免费的工具由 [csssprites.com]() (**图 3.10.**) 提供。它允许你上传多张小图然后自动生成一张大图：

![CSSSprites.com](http://img04.taobaocdn.com/tps/i4/T1ad8vXCxdXXX4U177-800-535.png "CSSSprites.com")

*图 3.10. CSSSprites.com*

* 小图
* 显示每张小图所需要的 CSS 代码
* 一个使用生成的精灵图和 CSS 代码的例子，可以看到真实页面的效果

### Data URIs

Data URIs 是一种可以把图片嵌入 HTML 页面或 CSS 样式文件中的技术。

相对于直接设置图片的 URL（或者 URI），这种技术允许你通过 URL 方式引用页面里面的内容（实际上就是里面的数据）

一般图片标签是这样的：

    <img src="http://example.org/myimage.png" />
    
而使用 data URI 的图片是这样的：

    <img src="data:image/png;base64,iVBOR...rkJggg==" />
    
这种语法也许有点吓人，但它包含了以下部分：

* `data:` - 代替了 `http:` 协议
* `image/png` - 图片的类型
* `base64` - 图片的编码类型
* 剩下逗号后面的内容就是文件的编码内容

因为图片内容是二进制的，有大量奇怪的字符会阻碍 HTML 代码的解析，所以用 base64 编码图片内容是很必要的。虽然可以指定编码的类型，但 base64 是现在浏览器中唯一支持的编码方法。Base64 就是用一堆字符（64 个）去代替二进制的内容。

大多数服务端的编程语言有内置的函数支持 base64 编解码。如 PHP 中有 `base64_encode()` 和 `base64_decode()`。看下面代码：

    <?php echo base64_encode('speed matters'); ?>
   
会输出 `c3BlZWQgbWF0dGVycw==`，这就是 base64 版的字符串 「speed matters」。

如果机器上安装有 PHP，则可以轻易地用命令行编码一个文件，如下：

    $ php -r "echo base64_encode(file_get_contents('myimage.png'));"
    
如果不习惯使用命令行或者服务端编程语言，也可以选择一些提供在线 base64 编解码的工具。

除了可以在 `<img />` 标签中使用 data URI 图片，在 CSS 样式中也可以使用这类图片，尤其是一些动态的样式，或者各种原因不能使用精灵图的情况。

在 CSS 中使用 data URI 的预发如下：

    .myclass {
      background-image: url("data:image/png;base64,iVBOR...rkJggg==");
    }


### 现实中的 data URI

如果你很好奇 data URI 是否真的有人在用，就让我们来看一些现实的例子吧。Google 和 Yahoo! 搜索非常在意它们的性能，所以它们线上都使用了 data URI。

Google 把 data URI 用于搜索结果视频和图片的缩略图，以减少大量的图片请求。Data URI 图片的缺点是无法缓存，而且让页面变得更重。不过如这个案例中的搜索结果，一般一个月后用户不会再看到同一张图片，因为用户很少会搜索重复的东西，而且很可能已经换成新的结果了。

![Google 搜索结果中的 data URI](http://img04.taobaocdn.com/tps/i4/T13BdwXrBbXXcQhvs7-800-565.png "Google 搜索结果中的 data URI")

*图 3.11. Google 搜索结果中的 data URI*

Yahoo! 搜索把 data URI 用于 CSS 中水平重复的渐变图案（**图 3.12.**）。如果用精灵图制作这种图案，很可能需要展开整个精灵图，浪费了大量图片空间。相反的，可以使用 data URL 在 CSS 文件里嵌入 1px 宽的图案。

![样式文件中的 data URI](http://img01.taobaocdn.com/tps/i1/T19sRvXttfXXX32uI7-800-473.png "样式文件中的 data URI")

*图 3.12. 样式文件中的 data URI*


### MHTML

现在你可能觉得 data URI 的预发很复杂，但一旦看过 MHTML 之后，你就不会这么觉得了。MHTML 是「最主流」的浏览器 - Internet Explorer 6 和 7 所支持的一项技术（你会觉得有关于网页设计的书不会提及 IE6 吗？）。Data URI 支持所有的现代浏览器，保留 IE8，但不支持 IE6 和 IE7。所以对于这个限制你可以有两个选择：

* 现代浏览器使用 data URI，IE6-7 使用传统的 URL。这样的话旧 IE 用户就得不到一致的优化体验，不过使用现代浏览器的用户是没有问题的。
* 都使用 data URI 但 IE8 以下使用 MHTML。

MHTML 意思是 MIME HTML，这是一个把多个文件（部分）嵌入一个文档的技术。MIME（Multipurpose Internet Mail Extensions 多用途邮件插件）一般用于邮件系统，可以使一封邮件里包含多个部分（纯文本、HTML、附件等）

让我们看下怎么用 MHTML 在 CSS 样式里嵌入文件。

首先，我们看一下用来表示一张图片的「部分」代码：

    Content-Location: myimage
    Content-Transfer-Encoding: base64

    iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAD....U5ErkJggg==
    
你也许可以猜到最长的那部分是使用了 base64 编码的文件内容。前面两行是描述文件的头信息，第一行是唯一辨识符 `myimage`，第二行则是编码方式 `base64`

为了能嵌入多个这些「部分」，我们需要把它们分隔开，一般会使用「分隔符」，如「MYSEPARATOR」。当然我们也需要一个「头信息」以跟文档的其它部分区分开，顺便定义一下这个「分隔符」是怎样的。最后，整个部分看起来是这样的：

    Content-Type: multipart/related; boundary="MYSEPARATOR"
 
    --MYSEPARATOR
    [here comes part one]
    --MYSEPARATOR
    [here is part two, followed by a final separator]
    --MYSEPARATOR--

注意里面的双横线，这是必须的。

我们需要把整个部分注释在 CSS 文件里。然后在 CSS 的 `background-image` 属性里引用唯一辨识符的文件，就像这样：

    .myclass {
      background-image: url(mhtml:http://example.org/styles.css!myimage);
    }

使用 MHTML 的 URL 会使用 `mthml:` 协议，接着是绝对路径的 URL，然后叹号跟着文件的唯一辨识符。

一个完整可用的 CSS 看起来像这样：

    /*
    Content-Type: multipart/related; boundary="MYSEPARATOR"

    --MYSEPARATOR
    Content-Location: myimage
    Content-Transfer-Encoding: base64

    iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAD....U5ErkJggg==
    --MYSEPARATOR
    Content-Location: another
    Content-Transfer-Encoding: base64

    iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAA....U5ErkJggg==
    --MYSEPARATOR--
    */
    .myclass {
      background-image: url(mhtml:http://example.org/styles.css!myimage);
    }

    .myotherclass {
      background-image: url(mhtml:http://example.org/styles.css!another);
    }
    

### MHTML 的缺点

当然的， MHTML 也存在一些缺点：

* 十分复杂。不过一旦有了自动化的服务端脚本自动为你生成 MHTML，这就变得没那么繁杂了，所以这也不算太大的问题。
* 所有的工作只是为了支持低级的 IE 浏览器。
* 如果你让所有浏览器都适用同一个样式，那就会加倍浏览器的流量，因为这张图片可能同时用 data URI 和 MHTML 编码在网页里。不过另外一个选择就是根据不同浏览器提供不同的样式文件。

这些有点严重的缺点让 MHTML 并不适用于大多数站点。不过如果你真的需要跨浏览器的超高速的体验，MHTML 在 IE8 以下的确是一个可行的方案。


## 「永不过期」策略

如果 50% 的用户访问时不带有任何缓存，这也意味着剩下的 50% 用户或多或少带有一些资源缓存在他们系统上的，我们也不能忽略他们。除了那些动态生成的内容和新图片，我们完全可以不用重复下载其它静态的资源以提高用户体验。为了提高这种重复访问的体验，我们需要采用「永不过期」的策略。

不过在深入之前，我们得简单看一下 HTTP 请求是长什么样的，它有着一定语法、头部信息（Headers）和主体部分（body）。

### HTTP 头部信息

浏览器和服务器之间用 HTTP 协议交流通信。浏览器发出请求，然后服务器响应。每一个请求和响应都有头部信息，但主体内容是可选的。主体内容就是实际上通信的内容，而头部信息则包含描述数据的一些信息。

> ## HTTP/TCP/IP 的关系
> 我们已经聊过数据包，它们也包含了一定的头信息和主体数据。现在我们来谈谈 HTTP 的头信息，看它们之间有什么关系。
> 当服务器需要给浏览器传送文件时，如一张图片，它会先在硬盘里找到这张图片，然后新建一个头信息表单，往里面填写这张图片的一些信息，紧接着用这个头信息表单和图片内容生成 HTTP 响应返回给浏览器。这个 HTTP 响应通过服务器软件中的 TCP 协议发送。TCP 协议把这个 HTTP 请求分割成很小的数据包，然后用 IP 协议这个向浏览器发送。

可以把 HTTP 响应想象成信箱中的信件。信件中的信则是响应的主题内容，寄件信息则代表头信息，上面写着你的信息、对方的信息和邮递员怎么处理这封信件等等。如果你是一个秘密特工，也许会告诉对方请阅后即焚。如果是一份万恶的缴税通知，你可能就要把这份文档保存在夹子里至少七年。在 HTTP 的头信息里，这些行为都会被介绍到。

要看头信息长什么样其实很简单。在 Firefox 里只要打开 Firebug 的网络面板然后展开其中一个请求（**图 3.13.**）

![Firebug 网络面板的 HTTP 头信息视图](http://img04.taobaocdn.com/tps/i4/T1OXRyXEXbXXaxHKA7-800-461.png "Firebug 网络面板的 HTTP 头信息视图")

一个简单的 HTTP 请求看起来是这样的：

    GET / HTTP/1.1
    Host: search.yahoo.com
    User-Agent: Mozilla/5.0 ...

请求的第一行意思是「获取 / 的页面」（ / 代表这这个域名下的根目录）。然后紧跟着一系列的 key-value 键值对。每个键值对占一行，键和值之间用冒号分隔。

类似的，HTTP 响应头信息第一行包含了响应结果（如，200 OK 或 404 Not Found），然后紧接着一系列键值对。头信息的最后会有一行空白，然后剩下的就是响应的主体内容。

    HTTP/1.1 200 OK
    Transfer-Encoding: chunked
    Content-Type: text/html; charset=UTF-8
    Content-Encoding: gzip

    <!doctype html>
    <html>
      <head><title>...

每一个头信息都有它的特殊含义和功能，其中的一些对性能优化来说很重要。我们会在本书剩下的部分逐个提及，但我们先从过期（Expires）信息开始。

### Expires 信息

Expires （过期）头信息是 HTTP 头信息中影响性能优化的重要信息之一。它用来告诉浏览器这个资源或文件应该保存多久（比如上面的「阅后即焚」或者「保存七年」）。

    Expires: Mon, 09 Sep 2019 07:04:49 GMT
    
上面这个例子表示这个文件保留缓存直到 2019 年。另一个头信息叫做 `Cache-Control:`，它描述了具体的过期时间，用秒数来表示而不是日期。这两个头信息都有助于缓存资源和文件。

一旦 `Expires` 头信息丢失，浏览器就会估计这个文件的过期时间，在觉得这个文件已经过期了或者有新版本的时候就会选择性地去发出请求。

「永不过期」策略就是把一些静态资源（如脚本、样式文件和图片）的过期时间设为很久很久以后，如十年之后。这是一件很简单的事情，只需要稍微配置一下服务器。假设服务器用 Apache（最主流的），只需要编辑一个叫 `.htaccess` 的文件（大多都空间服务商都允许编辑），添加以下内容：

    ExpiresActive On
    ExpiresByType application/x-javascript "access plus 10 years"
    ExpiresByType text/css "access plus 10 years"
    ExpiresByType image/png "access plus 10 years"

现在如果你在 2010/5/03 去请求一个 png 图片，Apache 就会添加一个这样的 HTTP 头。

    Expires: Sun, 03 May 2020 09:09:47 GMT

浏览器就会在 2020 年之前都不会去请求这个文件，也就是所谓的「永不过期」。

这种方法的缺点就是无法再去修改这个文件，因为这个文件已经被一些用户缓存到了 2020 年。如果需要修改，则需要存为别的文件名然后修改所有这个文件的引用。新的文件名你可以使用递增的数值，或者时间戳，再或者是文件内容的哈希值，这样文件名就对应了文件的实际内容。

> 要注意的是，设置了 Expires 头信息就不一定意味着这个文件一定存在于缓存内，它只是一个「建议」行为。浏览器不一定完全按照你说的去做，它只是「被建议」这么做。
